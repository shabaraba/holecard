Comparing 0c3481b -> working directory

diff --mote a/src/main.rs b/src/main.rs
--- a/src/main.rs
+++ b/src/main.rs
@@ -10,9 +10,43 @@ use copypasta::{ClipboardContext, ClipboardProvider};
 use domain::{CryptoService, Entry, Vault};
 use infrastructure::{CryptoServiceImpl, KeyringManager, VaultStorage};
+use std::path::PathBuf;
 use std::thread;
 use std::time::Duration;
 
+struct VaultContext {
+    vault: Vault,
+    storage: VaultStorage<CryptoServiceImpl>,
+    master_password: String,
+    secret_key: String,
+    config: Config,
+}
+
+impl VaultContext {
+    fn load(keyring: &KeyringManager, config_dir: &PathBuf) -> Result<Self> {
+        let secret_key = keyring.load_secret_key()?;
+        let master_password = input::prompt_master_password()?;
+        let config = Config::load(config_dir)?;
+        let crypto = CryptoServiceImpl::new();
+        let storage = VaultStorage::new(crypto);
+        let vault = storage.load(&config.vault_path, &master_password, &secret_key)
+            .map_err(|e| anyhow::anyhow!("{}", e))?;
+
+        Ok(Self {
+            vault,
+            storage,
+            master_password,
+            secret_key,
+            config,
+        })
+    }
+
+    fn save(&self) -> Result<()> {
+        self.storage.save(&self.vault, &self.config.vault_path, &self.master_password, &self.secret_key)
+            .map_err(|e| anyhow::anyhow!("{}", e))
+    }
+}
+
 fn main() -> Result<()> {
     let cli = Cli::parse();
     let config_dir = get_config_dir()?;
@@ -38,15 +72,22 @@     let crypto = CryptoServiceImpl::new();
     let secret_key = crypto.generate_secret_key();
 
+    keyring.save_secret_key(&secret_key)?;
+
+    let secret_key_path = config_dir.join("secret_key_backup.txt");
+    std::fs::write(&secret_key_path, &secret_key)
+        .context("Failed to write secret key backup")?;
+
     println!("\n========================================");
-    println!("           Secret Key");
+    println!("     Vault Initialization Complete");
     println!("========================================");
-    println!("\n{}\n", secret_key);
-    println!("IMPORTANT: Save this Secret Key in a secure location.");
-    println!("You will need it along with your Master Password to access your vault.");
+    println!("\nSecret Key has been saved to:");
+    println!("  {}", secret_key_path.display());
+    println!("\nIMPORTANT:");
+    println!("  1. Copy this file to a secure backup location");
+    println!("  2. Delete the file after backing up: rm {}", secret_key_path.display());
+    println!("  3. You will need the Secret Key + Master Password to access your vault");
     println!("========================================\n");
-
-    keyring.save_secret_key(&secret_key)?;
 
     let master_password = input::prompt_master_password_confirm()?;
 
@@ -66,14 +107,7 @@     keyring: &KeyringManager,
     config_dir: &std::path::PathBuf,
 ) -> Result<()> {
-    let secret_key = keyring.load_secret_key()?;
-    let master_password = input::prompt_master_password()?;
-
-    let config = Config::load(config_dir)?;
-    let crypto = CryptoServiceImpl::new();
-    let storage = VaultStorage::new(crypto);
-
-    let mut vault = storage.load(&config.vault_path, &master_password, &secret_key)?;
+    let mut ctx = VaultContext::load(keyring, config_dir)?;
 
     let entry_name = name.unwrap_or_else(|| input::prompt_entry_name().unwrap());
 
@@ -86,9 +120,9 @@     let notes = input::prompt_notes()?;
 
     let entry = Entry::new(entry_name.clone(), custom_fields, notes);
-    vault.add_entry(entry)?;
+    ctx.vault.add_entry(entry).map_err(|e| anyhow::anyhow!("{}", e))?;
 
-    storage.save(&vault, &config.vault_path, &master_password, &secret_key)?;
+    ctx.save()?;
 
     println!("✓ Entry '{}' added successfully!", entry_name);
     Ok(())
@@ -100,15 +134,8 @@     keyring: &KeyringManager,
     config_dir: &std::path::PathBuf,
 ) -> Result<()> {
-    let secret_key = keyring.load_secret_key()?;
-    let master_password = input::prompt_master_password()?;
-
-    let config = Config::load(config_dir)?;
-    let crypto = CryptoServiceImpl::new();
-    let storage = VaultStorage::new(crypto);
-
-    let vault = storage.load(&config.vault_path, &master_password, &secret_key)?;
-    let entry = vault.get_entry(name)?;
+    let ctx = VaultContext::load(keyring, config_dir)?;
+    let entry = ctx.vault.get_entry(name).map_err(|e| anyhow::anyhow!("{}", e))?;
 
     println!("\nEntry: {}", entry.name);
     println!("Created: {}", entry.created_at.format("%Y-%m-%d %H:%M:%S"));
@@ -151,15 +178,8 @@ }
 
 fn handle_list(keyring: &KeyringManager, config_dir: &std::path::PathBuf) -> Result<()> {
-    let secret_key = keyring.load_secret_key()?;
-    let master_password = input::prompt_master_password()?;
-
-    let config = Config::load(config_dir)?;
-    let crypto = CryptoServiceImpl::new();
-    let storage = VaultStorage::new(crypto);
-
-    let vault = storage.load(&config.vault_path, &master_password, &secret_key)?;
-    let entries = vault.list_entries();
+    let ctx = VaultContext::load(keyring, config_dir)?;
+    let entries = ctx.vault.list_entries();
 
     if entries.is_empty() {
         println!("No entries found.");
@@ -178,16 +198,9 @@ }
 
 fn handle_edit(name: &str, keyring: &KeyringManager, config_dir: &std::path::PathBuf) -> Result<()> {
-    let secret_key = keyring.load_secret_key()?;
-    let master_password = input::prompt_master_password()?;
+    let mut ctx = VaultContext::load(keyring, config_dir)?;
 
-    let config = Config::load(config_dir)?;
-    let crypto = CryptoServiceImpl::new();
-    let storage = VaultStorage::new(crypto);
-
-    let mut vault = storage.load(&config.vault_path, &master_password, &secret_key)?;
-
-    let entry = vault.get_entry_mut(name)?;
+    let entry = ctx.vault.get_entry_mut(name).map_err(|e| anyhow::anyhow!("{}", e))?;
     println!("Editing entry: {}", entry.name);
 
     let new_fields = input::prompt_custom_fields()?;
@@ -196,25 +209,18 @@     let new_notes = input::prompt_notes()?;
     entry.update_notes(new_notes);
 
-    storage.save(&vault, &config.vault_path, &master_password, &secret_key)?;
+    ctx.save()?;
 
     println!("✓ Entry '{}' updated successfully!", name);
     Ok(())
 }
 
 fn handle_rm(name: &str, keyring: &KeyringManager, config_dir: &std::path::PathBuf) -> Result<()> {
-    let secret_key = keyring.load_secret_key()?;
-    let master_password = input::prompt_master_password()?;
+    let mut ctx = VaultContext::load(keyring, config_dir)?;
 
-    let config = Config::load(config_dir)?;
-    let crypto = CryptoServiceImpl::new();
-    let storage = VaultStorage::new(crypto);
-
-    let mut vault = storage.load(&config.vault_path, &master_password, &secret_key)?;
+    ctx.vault.remove_entry(name).map_err(|e| anyhow::anyhow!("{}", e))?;
 
-    vault.remove_entry(name)?;
-
-    storage.save(&vault, &config.vault_path, &master_password, &secret_key)?;
+    ctx.save()?;
 
     println!("✓ Entry '{}' removed successfully!", name);
     Ok(())

diff --mote a/src/infrastructure/crypto_impl.rs b/src/infrastructure/crypto_impl.rs
--- a/src/infrastructure/crypto_impl.rs
+++ b/src/infrastructure/crypto_impl.rs
@@ -1,15 +1,15 @@-use crate::domain::CryptoService;
+use crate::domain::{CryptoError, CryptoService};
 use aes_gcm::{
     aead::{Aead, KeyInit, OsRng},
     Aes256Gcm, Nonce,
 };
-use anyhow::{anyhow, Result};
-use argon2::Argon2;
+use argon2::{Algorithm, Argon2, Params, Version};
 use rand::RngCore;
 use zeroize::Zeroize;
 
 const SALT_LEN: usize = 16;
 const NONCE_LEN: usize = 12;
+const MIN_ENCRYPTED_LEN: usize = SALT_LEN + NONCE_LEN + 16;
 
 pub struct CryptoServiceImpl;
 
@@ -18,13 +18,21 @@         Self
     }
 
-    fn derive_key(&self, master_password: &str, secret_key: &str, salt: &[u8]) -> Result<[u8; 32]> {
-        let mut combined = format!("{}{}", master_password, secret_key);
+    fn derive_key(&self, master_password: &str, secret_key: &str, salt: &[u8]) -> Result<[u8; 32], CryptoError> {
+        let mut combined = Vec::new();
+        combined.extend_from_slice(master_password.as_bytes());
+        combined.extend_from_slice(b"|");
+        combined.extend_from_slice(secret_key.as_bytes());
+
         let mut output_key = [0u8; 32];
 
-        Argon2::default()
-            .hash_password_into(combined.as_bytes(), salt, &mut output_key)
-            .map_err(|e| anyhow!("Key derivation failed: {}", e))?;
+        let params = Params::new(19 * 1024, 2, 1, Some(32))
+            .map_err(|e| CryptoError::KeyDerivationFailed(e.to_string()))?;
+        let argon2 = Argon2::new(Algorithm::Argon2id, Version::V0x13, params);
+
+        argon2
+            .hash_password_into(&combined, salt, &mut output_key)
+            .map_err(|e| CryptoError::KeyDerivationFailed(e.to_string()))?;
 
         combined.zeroize();
         Ok(output_key)
@@ -32,7 +40,7 @@ }
 
 impl CryptoService for CryptoServiceImpl {
-    fn encrypt(&self, data: &[u8], master_password: &str, secret_key: &str) -> Result<Vec<u8>> {
+    fn encrypt(&self, data: &[u8], master_password: &str, secret_key: &str) -> Result<Vec<u8>, CryptoError> {
         let mut salt = [0u8; SALT_LEN];
         OsRng.fill_bytes(&mut salt);
 
@@ -41,12 +49,12 @@ 
         let mut key = self.derive_key(master_password, secret_key, &salt)?;
         let cipher = Aes256Gcm::new_from_slice(&key)
-            .map_err(|e| anyhow!("Cipher initialization failed: {}", e))?;
+            .map_err(|e| CryptoError::CipherInitFailed(e.to_string()))?;
 
         let nonce = Nonce::from_slice(&nonce_bytes);
         let ciphertext = cipher
             .encrypt(nonce, data)
-            .map_err(|e| anyhow!("Encryption failed: {}", e))?;
+            .map_err(|e| CryptoError::EncryptionFailed(e.to_string()))?;
 
         key.zeroize();
 
@@ -58,9 +66,9 @@         Ok(result)
     }
 
-    fn decrypt(&self, encrypted_data: &[u8], master_password: &str, secret_key: &str) -> Result<Vec<u8>> {
-        if encrypted_data.len() < SALT_LEN + NONCE_LEN {
-            return Err(anyhow!("Invalid encrypted data: too short"));
+    fn decrypt(&self, encrypted_data: &[u8], master_password: &str, secret_key: &str) -> Result<Vec<u8>, CryptoError> {
+        if encrypted_data.len() < MIN_ENCRYPTED_LEN {
+            return Err(CryptoError::InvalidData("too short".to_string()));
         }
 
         let salt = &encrypted_data[..SALT_LEN];
@@ -69,12 +77,12 @@ 
         let mut key = self.derive_key(master_password, secret_key, salt)?;
         let cipher = Aes256Gcm::new_from_slice(&key)
-            .map_err(|e| anyhow!("Cipher initialization failed: {}", e))?;
+            .map_err(|e| CryptoError::CipherInitFailed(e.to_string()))?;
 
         let nonce = Nonce::from_slice(nonce_bytes);
         let plaintext = cipher
             .decrypt(nonce, ciphertext)
-            .map_err(|_| anyhow!("Decryption failed: incorrect password or corrupted data"))?;
+            .map_err(|_| CryptoError::DecryptionFailed)?;
 
         key.zeroize();
         Ok(plaintext)

diff --mote a/src/infrastructure/storage.rs b/src/infrastructure/storage.rs
--- a/src/infrastructure/storage.rs
+++ b/src/infrastructure/storage.rs
@@ -1,5 +1,4 @@-use crate::domain::{CryptoService, Vault};
-use anyhow::{Context, Result};
+use crate::domain::{CryptoError, CryptoService, Vault};
 use std::fs;
 use std::path::Path;
 
@@ -12,46 +11,55 @@         Self { crypto }
     }
 
-    pub fn load(&self, path: &Path, master_password: &str, secret_key: &str) -> Result<Vault> {
+    pub fn load(&self, path: &Path, master_password: &str, secret_key: &str) -> Result<Vault, CryptoError> {
         if !path.exists() {
             return Ok(Vault::new());
         }
 
-        let encrypted_data = fs::read(path).context("Failed to read vault file")?;
+        let encrypted_data = fs::read(path)
+            .map_err(|e| CryptoError::InvalidData(format!("Failed to read vault file: {}", e)))?;
 
         let decrypted_data = self
             .crypto
-            .decrypt(&encrypted_data, master_password, secret_key)
-            .context("Failed to decrypt vault")?;
+            .decrypt(&encrypted_data, master_password, secret_key)?;
 
         let vault: Vault = serde_json::from_slice(&decrypted_data)
-            .context("Failed to deserialize vault")?;
+            .map_err(|e| CryptoError::InvalidData(format!("Failed to deserialize vault: {}", e)))?;
 
         Ok(vault)
     }
 
-    pub fn save(&self, vault: &Vault, path: &Path, master_password: &str, secret_key: &str) -> Result<()> {
+    pub fn save(&self, vault: &Vault, path: &Path, master_password: &str, secret_key: &str) -> Result<(), CryptoError> {
         if let Some(parent) = path.parent() {
-            fs::create_dir_all(parent).context("Failed to create vault directory")?;
+            fs::create_dir_all(parent)
+                .map_err(|e| CryptoError::InvalidData(format!("Failed to create vault directory: {}", e)))?;
         }
 
-        let json_data = serde_json::to_vec(vault).context("Failed to serialize vault")?;
+        let json_data = serde_json::to_vec(vault)
+            .map_err(|e| CryptoError::InvalidData(format!("Failed to serialize vault: {}", e)))?;
 
         let encrypted_data = self
             .crypto
-            .encrypt(&json_data, master_password, secret_key)
-            .context("Failed to encrypt vault")?;
+            .encrypt(&json_data, master_password, secret_key)?;
 
-        fs::write(path, encrypted_data).context("Failed to write vault file")?;
+        let temp_path = path.with_extension("tmp");
+        fs::write(&temp_path, encrypted_data)
+            .map_err(|e| CryptoError::InvalidData(format!("Failed to write vault file: {}", e)))?;
 
         #[cfg(unix)]
         {
             use std::os::unix::fs::PermissionsExt;
-            let mut perms = fs::metadata(path)?.permissions();
+            let mut perms = fs::metadata(&temp_path)
+                .map_err(|e| CryptoError::InvalidData(format!("Failed to get file metadata: {}", e)))?
+                .permissions();
             perms.set_mode(0o600);
-            fs::set_permissions(path, perms)?;
+            fs::set_permissions(&temp_path, perms)
+                .map_err(|e| CryptoError::InvalidData(format!("Failed to set file permissions: {}", e)))?;
         }
 
+        fs::rename(&temp_path, path)
+            .map_err(|e| CryptoError::InvalidData(format!("Failed to finalize vault file: {}", e)))?;
+
         Ok(())
     }
 }

diff --mote a/src/infrastructure/keyring.rs b/src/infrastructure/keyring.rs
--- a/src/infrastructure/keyring.rs
+++ b/src/infrastructure/keyring.rs
@@ -40,26 +40,24 @@     }
 
     pub fn load_secret_key(&self) -> Result<String> {
-        match Entry::new(SERVICE_NAME, USERNAME) {
-            Ok(entry) => match entry.get_password() {
-                Ok(key) => Ok(key),
-                Err(_) => {
-                    if self.fallback_path.exists() {
-                        fs::read_to_string(&self.fallback_path)
-                            .context("Failed to read secret key from fallback file")
-                    } else {
-                        Err(anyhow::anyhow!("Secret key not found. Please run 'pm init' first."))
-                    }
-                }
-            },
-            Err(_) => {
-                if self.fallback_path.exists() {
-                    fs::read_to_string(&self.fallback_path)
-                        .context("Failed to read secret key from fallback file")
-                } else {
-                    Err(anyhow::anyhow!("Secret key not found. Please run 'pm init' first."))
-                }
-            }
+        let try_keyring = || -> Option<String> {
+            Entry::new(SERVICE_NAME, USERNAME)
+                .ok()?
+                .get_password()
+                .ok()
+                .map(|s| s.trim().to_string())
+        };
+
+        if let Some(key) = try_keyring() {
+            return Ok(key);
+        }
+
+        if self.fallback_path.exists() {
+            fs::read_to_string(&self.fallback_path)
+                .map(|s| s.trim().to_string())
+                .context("Failed to read secret key from fallback file")
+        } else {
+            Err(anyhow::anyhow!("Secret key not found. Please run 'pm init' first."))
         }
     }
 }

diff --mote a/src/domain/error.rs b/src/domain/error.rs
--- a/src/domain/error.rs
+++ b/src/domain/error.rs
@@ -0,0 +1,28 @@+use thiserror::Error;
+
+#[derive(Error, Debug)]
+pub enum VaultError {
+    #[error("Entry '{0}' already exists")]
+    EntryAlreadyExists(String),
+
+    #[error("Entry '{0}' not found")]
+    EntryNotFound(String),
+}
+
+#[derive(Error, Debug)]
+pub enum CryptoError {
+    #[error("Key derivation failed: {0}")]
+    KeyDerivationFailed(String),
+
+    #[error("Encryption failed: {0}")]
+    EncryptionFailed(String),
+
+    #[error("Decryption failed: incorrect password or corrupted data")]
+    DecryptionFailed,
+
+    #[error("Cipher initialization failed: {0}")]
+    CipherInitFailed(String),
+
+    #[error("Invalid encrypted data: {0}")]
+    InvalidData(String),
+}

diff --mote a/src/domain/mod.rs b/src/domain/mod.rs
--- a/src/domain/mod.rs
+++ b/src/domain/mod.rs
@@ -1,7 +1,11 @@ pub mod crypto;
 pub mod entry;
+pub mod error;
 pub mod vault;
 
 pub use crypto::CryptoService;
 pub use entry::Entry;
+pub use error::CryptoError;
+#[allow(unused_imports)]
+pub use error::VaultError;
 pub use vault::Vault;

diff --mote a/src/domain/vault.rs b/src/domain/vault.rs
--- a/src/domain/vault.rs
+++ b/src/domain/vault.rs
@@ -1,5 +1,5 @@ use super::entry::Entry;
-use anyhow::{anyhow, Result};
+use super::error::VaultError;
 use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 
@@ -15,30 +15,30 @@         }
     }
 
-    pub fn add_entry(&mut self, entry: Entry) -> Result<()> {
+    pub fn add_entry(&mut self, entry: Entry) -> Result<(), VaultError> {
         if self.entries.contains_key(&entry.name) {
-            return Err(anyhow!("Entry '{}' already exists", entry.name));
+            return Err(VaultError::EntryAlreadyExists(entry.name.clone()));
         }
         self.entries.insert(entry.name.clone(), entry);
         Ok(())
     }
 
-    pub fn get_entry(&self, name: &str) -> Result<&Entry> {
+    pub fn get_entry(&self, name: &str) -> Result<&Entry, VaultError> {
         self.entries
             .get(name)
-            .ok_or_else(|| anyhow!("Entry '{}' not found", name))
+            .ok_or_else(|| VaultError::EntryNotFound(name.to_string()))
     }
 
-    pub fn get_entry_mut(&mut self, name: &str) -> Result<&mut Entry> {
+    pub fn get_entry_mut(&mut self, name: &str) -> Result<&mut Entry, VaultError> {
         self.entries
             .get_mut(name)
-            .ok_or_else(|| anyhow!("Entry '{}' not found", name))
+            .ok_or_else(|| VaultError::EntryNotFound(name.to_string()))
     }
 
-    pub fn remove_entry(&mut self, name: &str) -> Result<Entry> {
+    pub fn remove_entry(&mut self, name: &str) -> Result<Entry, VaultError> {
         self.entries
             .remove(name)
-            .ok_or_else(|| anyhow!("Entry '{}' not found", name))
+            .ok_or_else(|| VaultError::EntryNotFound(name.to_string()))
     }
 
     pub fn list_entries(&self) -> Vec<&Entry> {

diff --mote a/src/domain/crypto.rs b/src/domain/crypto.rs
--- a/src/domain/crypto.rs
+++ b/src/domain/crypto.rs
@@ -1,7 +1,7 @@-use anyhow::Result;
+use super::error::CryptoError;
 
 pub trait CryptoService {
-    fn encrypt(&self, data: &[u8], master_password: &str, secret_key: &str) -> Result<Vec<u8>>;
-    fn decrypt(&self, encrypted_data: &[u8], master_password: &str, secret_key: &str) -> Result<Vec<u8>>;
+    fn encrypt(&self, data: &[u8], master_password: &str, secret_key: &str) -> Result<Vec<u8>, CryptoError>;
+    fn decrypt(&self, encrypted_data: &[u8], master_password: &str, secret_key: &str) -> Result<Vec<u8>, CryptoError>;
     fn generate_secret_key(&self) -> String;
 }

